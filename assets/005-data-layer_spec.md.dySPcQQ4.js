import{_ as n,C as l,o as a,c as h,a2 as o,b as d,w as t,a as s,E as c,a3 as i}from"./chunks/framework.C-cuuT8Z.js";const y=JSON.parse('{"title":"Feature: Data Layer Services Setup","description":"","frontmatter":{},"headers":[],"relativePath":"005-data-layer/spec.md","filePath":"005-data-layer/spec.md","lastUpdated":1772310733000}'),p={name:"005-data-layer/spec.md"};function u(m,e,g,b,v,k){const r=l("Mermaid");return a(),h("div",null,[e[2]||(e[2]=o('<h1 id="feature-data-layer-services-setup" tabindex="-1">Feature: Data Layer Services Setup <a class="header-anchor" href="#feature-data-layer-services-setup" aria-label="Permalink to &quot;Feature: Data Layer Services Setup&quot;">​</a></h1><blockquote><p><strong>Spec</strong>: 005-data-layer <strong>Author</strong>: arc-framework <strong>Date</strong>: 2026-02-28 <strong>Status</strong>: Draft</p></blockquote><h2 id="target-modules" tabindex="-1">Target Modules <a class="header-anchor" href="#target-modules" aria-label="Permalink to &quot;Target Modules&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Module</th><th>Path</th><th>Impact</th></tr></thead><tbody><tr><td>Services</td><td><code>services/persistence/</code></td><td>New — Postgres 17 (Oracle), port 5432</td></tr><tr><td>Services</td><td><code>services/vector/</code></td><td>New — Qdrant (Cerebro), ports 6333/6334</td></tr><tr><td>Services</td><td><code>services/storage/</code></td><td>New — MinIO (Tardis), ports 9000/9001</td></tr><tr><td>Services</td><td><code>services/profiles.yaml</code></td><td>Update — oracle + cerebro → <code>think</code>; tardis → <code>reason</code></td></tr><tr><td>CI/CD</td><td><code>.github/workflows/</code></td><td>New — data-images.yml + data-release.yml</td></tr><tr><td>Makefile</td><td><code>Makefile</code>, <code>*.mk</code></td><td>New — oracle.mk, cerebro.mk, tardis.mk, data.mk</td></tr></tbody></table><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Provision Postgres 17 (Oracle), Qdrant (Cerebro), and MinIO (Tardis) as production-grade platform services in the arc-platform monorepo. These three services form the persistent data backbone — relational state, vector embeddings, and object storage — that Cortex bootstraps against, AI agents use for memory and retrieval, and future services depend on. Each follows the canonical pattern from 003-messaging-setup: thin Dockerfile label wrapper, <code>service.yaml</code>, <code>docker-compose.yml</code>, dedicated <code>.mk</code> include, and CI/release workflows.</p><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">​</a></h2>',7)),(a(),d(i,null,{default:t(()=>[c(r,{id:"mermaid-103",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20subgraph%20arc_platform_net%0A%20%20%20%20%20%20%20%20oracle%5B%22arc-sql-db%5Cn(Postgres%2017)%5Cn%3A5432%22%5D%0A%20%20%20%20%20%20%20%20cerebro%5B%22arc-vector-db%5Cn(Qdrant)%5Cn%3A6333%20REST%20%C2%B7%20%3A6334%20gRPC%22%5D%0A%20%20%20%20%20%20%20%20tardis%5B%22arc-storage%5Cn(MinIO)%5Cn%3A9000%20S3%20%C2%B7%20%3A9001%20console%22%5D%0A%20%20%20%20end%0A%0A%20%20%20%20cortex%5B%22arc-cortex%5Cn(%3A8081)%22%5D%20--%3E%7Cschema%20bootstrap%5CnSQL%20queries%7C%20oracle%0A%20%20%20%20mystique_future%5B%22arc-flags%20(future)%5CnUnleash%20flags%22%5D%20--%3E%7Cfeature%20flag%20state%7C%20oracle%0A%20%20%20%20sherlock%5B%22arc-sherlock%20(future)%5CnReasoner%22%5D%20--%3E%7Cvector%20search%5Cnembedding%20store%7C%20cerebro%0A%20%20%20%20scarlett%5B%22arc-scarlett%20(future)%5CnVoice%20Agent%22%5D%20--%3E%7Cbinary%20assets%5Cnrecordings%7C%20tardis%0A%20%20%20%20agents%5B%22AI%20Agents%22%5D%20--%3E%7Csemantic%20memory%5CnRAG%20retrieval%7C%20cerebro%0A%20%20%20%20agents%20--%3E%7Cartifact%20storage%5Cnoutput%20files%7C%20tardis%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[s(" Loading... ",-1)])]),_:1})),e[3]||(e[3]=o(`<h3 id="service-roles" tabindex="-1">Service Roles <a class="header-anchor" href="#service-roles" aria-label="Permalink to &quot;Service Roles&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Codename</th><th>Service</th><th>Role</th><th>When to Use</th></tr></thead><tbody><tr><td>Oracle</td><td>Postgres 17</td><td>Relational state, schemas, FK constraints</td><td>Structured data, audit logs, Unleash state</td></tr><tr><td>Cerebro</td><td>Qdrant</td><td>Vector embeddings, semantic search</td><td>RAG pipelines, agent memory, similarity queries</td></tr><tr><td>Tardis</td><td>MinIO (S3)</td><td>Object storage, binary assets</td><td>Files, recordings, model weights, large blobs</td></tr></tbody></table><h3 id="directory-layout" tabindex="-1">Directory Layout <a class="header-anchor" href="#directory-layout" aria-label="Permalink to &quot;Directory Layout&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>services/</span></span>
<span class="line"><span>├── persistence/        ← Oracle (Postgres 17)</span></span>
<span class="line"><span>│   ├── Dockerfile</span></span>
<span class="line"><span>│   ├── service.yaml</span></span>
<span class="line"><span>│   ├── docker-compose.yml</span></span>
<span class="line"><span>│   └── oracle.mk</span></span>
<span class="line"><span>├── vector/             ← Cerebro (Qdrant)</span></span>
<span class="line"><span>│   ├── Dockerfile</span></span>
<span class="line"><span>│   ├── service.yaml</span></span>
<span class="line"><span>│   ├── docker-compose.yml</span></span>
<span class="line"><span>│   └── cerebro.mk</span></span>
<span class="line"><span>└── storage/            ← Tardis (MinIO)</span></span>
<span class="line"><span>    ├── Dockerfile</span></span>
<span class="line"><span>    ├── service.yaml</span></span>
<span class="line"><span>    ├── docker-compose.yml</span></span>
<span class="line"><span>    └── tardis.mk</span></span></code></pre></div><h2 id="user-scenarios-testing" tabindex="-1">User Scenarios &amp; Testing <a class="header-anchor" href="#user-scenarios-testing" aria-label="Permalink to &quot;User Scenarios &amp; Testing&quot;">​</a></h2><h3 id="p1-—-must-have" tabindex="-1">P1 — Must Have <a class="header-anchor" href="#p1-—-must-have" aria-label="Permalink to &quot;P1 — Must Have&quot;">​</a></h3><p><strong>US-1</strong>: As a platform developer, I want to start all three data services with a single make command so that my local dev environment has persistence ready immediately.</p><ul><li><strong>Given</strong>: Docker is running and <code>arc_platform_net</code> exists</li><li><strong>When</strong>: <code>make data-up</code> is executed</li><li><strong>Then</strong>: Oracle, Cerebro, and Tardis start; all Docker health checks pass</li><li><strong>Test</strong>: <code>make data-health</code> exits 0</li></ul><p><strong>US-2</strong>: As a platform developer, I want Cortex to report <code>oracle: ok</code> in <code>/health/deep</code> so that I know the data layer is wired correctly.</p><ul><li><strong>Given</strong>: <code>make data-up</code> has succeeded and <code>arc-cortex</code> is running</li><li><strong>When</strong>: <code>curl http://localhost:8081/health/deep</code> is called</li><li><strong>Then</strong>: Response shows <code>&quot;oracle&quot;: {&quot;status&quot;: &quot;ok&quot;}</code> (not &quot;connection refused&quot;)</li><li><strong>Test</strong>: <code>curl -s http://localhost:8081/health/deep | jq .oracle.status</code></li></ul><p><strong>US-3</strong>: As a CI consumer, I want Docker images for all three services built and pushed on main branch merges so the team always has fresh images.</p><ul><li><strong>Given</strong>: A commit merges to main touching <code>services/persistence/**</code>, <code>services/vector/**</code>, or <code>services/storage/**</code></li><li><strong>When</strong>: <code>data-images.yml</code> workflow runs</li><li><strong>Then</strong>: Images <code>ghcr.io/arc-framework/arc-sql-db</code>, <code>arc-vector-db</code>, <code>arc-storage</code> are updated</li><li><strong>Test</strong>: Inspect GHCR after CI completes; verify <code>sha-*</code> tag present</li></ul><h3 id="p2-—-should-have" tabindex="-1">P2 — Should Have <a class="header-anchor" href="#p2-—-should-have" aria-label="Permalink to &quot;P2 — Should Have&quot;">​</a></h3><p><strong>US-4</strong>: As a platform developer, I want each data service to have <code>service.yaml</code> so the arc CLI and Cortex can discover them declaratively.</p><ul><li><strong>Test</strong>: <code>cat services/persistence/service.yaml</code> contains name, ports, health, depends_on</li></ul><p><strong>US-5</strong>: As a release engineer, I want to publish versioned images for all three services via a single <code>data/vX.Y.Z</code> git tag so that data layer releases are atomic.</p><ul><li><strong>Test</strong>: Push tag <code>data/v0.1.0</code>; <code>data-release.yml</code> builds + pushes all three images with <code>data-v0.1.0</code> tag</li></ul><p><strong>US-6</strong>: As a platform developer, I want <code>make data-up</code> / <code>make data-down</code> / <code>make data-health</code> to aggregate all three services, mirroring the <code>messaging-*</code> UX.</p><ul><li><strong>Test</strong>: Both commands work end-to-end; subsequent <code>make data-up</code> is idempotent</li></ul><h3 id="p3-—-nice-to-have" tabindex="-1">P3 — Nice to Have <a class="header-anchor" href="#p3-—-nice-to-have" aria-label="Permalink to &quot;P3 — Nice to Have&quot;">​</a></h3><p><strong>US-7</strong>: As a developer, I want <code>make data-logs</code> to tail logs from all three containers simultaneously so I can debug data layer issues without multiple terminals.</p><ul><li><strong>Test</strong>: <code>make data-logs</code> fans out to Oracle, Cerebro, and Tardis log streams with service prefixes</li></ul><p><strong>US-8</strong>: As a developer, I want the MinIO console accessible at <code>http://localhost:9001</code> so I can browse buckets and inspect objects during development.</p><ul><li><strong>Test</strong>: Navigate to <code>http://localhost:9001</code>; log in with <code>arc</code> / <code>arc-minio-dev</code></li></ul><h2 id="requirements" tabindex="-1">Requirements <a class="header-anchor" href="#requirements" aria-label="Permalink to &quot;Requirements&quot;">​</a></h2><h3 id="functional" tabindex="-1">Functional <a class="header-anchor" href="#functional" aria-label="Permalink to &quot;Functional&quot;">​</a></h3><ul><li>[ ] FR-1: Create <code>services/persistence/</code> with a Postgres 17 Dockerfile using <code>postgres:17-alpine</code>, <code>service.yaml</code>, <code>docker-compose.yml</code>, and <code>oracle.mk</code></li><li>[ ] FR-2: Create <code>services/vector/</code> with a Qdrant Dockerfile using <code>qdrant/qdrant</code>, <code>service.yaml</code>, <code>docker-compose.yml</code>, and <code>cerebro.mk</code></li><li>[ ] FR-3: Create <code>services/storage/</code> with a MinIO Dockerfile using <code>minio/minio</code>, <code>service.yaml</code>, <code>docker-compose.yml</code>, and <code>tardis.mk</code></li><li>[ ] FR-4: Oracle must initialize with default DB <code>arc</code>, user <code>arc</code>, password <code>arc</code>; data persisted to named volume <code>arc-sql-db-data</code></li><li>[ ] FR-5: Cerebro (Qdrant) must persist vector data to named volume <code>arc-vector-db-data</code>; both REST (:6333) and gRPC (:6334) exposed on localhost</li><li>[ ] FR-6: Tardis (MinIO) must expose S3 API (:9000) and console (:9001); data persisted to named volume <code>arc-storage-data</code>; root credentials via <code>MINIO_ROOT_USER</code> / <code>MINIO_ROOT_PASSWORD</code> env</li><li>[ ] FR-7: Update <code>services/profiles.yaml</code> — add <code>oracle</code> + <code>cerebro</code> to <code>think</code> profile; <code>tardis</code> to <code>reason</code> profile</li><li>[ ] FR-8: Create <code>data-images.yml</code> CI workflow — path-filtered per service directory, builds all three, <code>linux/amd64</code> in CI</li><li>[ ] FR-9: Create <code>data-release.yml</code> release workflow — tag format <code>data/vX.Y.Z</code>, builds all three multi-platform (<code>linux/amd64,linux/arm64</code>), creates GitHub release</li><li>[ ] FR-10: Create <code>services/data.mk</code> aggregate with <code>data-up</code>, <code>data-down</code>, <code>data-health</code>, <code>data-logs</code> targets</li><li>[ ] FR-11: Include <code>oracle.mk</code>, <code>cerebro.mk</code>, <code>tardis.mk</code>, <code>data.mk</code> in root Makefile</li></ul><h3 id="non-functional" tabindex="-1">Non-Functional <a class="header-anchor" href="#non-functional" aria-label="Permalink to &quot;Non-Functional&quot;">​</a></h3><ul><li>[ ] NFR-1: Oracle runs as <code>postgres</code> user (uid 70 in alpine); Cerebro runs as non-root (qdrant uid 1000); MinIO runs as non-root (verify against upstream <code>minio/minio</code> image)</li><li>[ ] NFR-2: All services expose health endpoints consumable by Docker health checks with appropriate <code>start_period</code> (Oracle: 10s, Cerebro: 5s, MinIO: 5s)</li><li>[ ] NFR-3: Data volumes must use named Docker volumes — no bind mounts</li><li>[ ] NFR-4: All ports bind to <code>127.0.0.1</code> only — no <code>0.0.0.0</code> exposure</li><li>[ ] NFR-5: Docker images include standard OCI (<code>org.opencontainers.*</code>) and <code>arc.service.*</code> labels</li><li>[ ] NFR-6: CI build completes in under 3 minutes (amd64 only; no QEMU)</li></ul><h3 id="key-entities" tabindex="-1">Key Entities <a class="header-anchor" href="#key-entities" aria-label="Permalink to &quot;Key Entities&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Entity</th><th>Module</th><th>Description</th></tr></thead><tbody><tr><td><code>arc-sql-db</code></td><td><code>services/persistence/</code></td><td>Postgres 17; relational state store for Cortex, Unleash, and future services</td></tr><tr><td><code>arc-vector-db</code></td><td><code>services/vector/</code></td><td>Qdrant; vector DB for agent embeddings and semantic search</td></tr><tr><td><code>arc-storage</code></td><td><code>services/storage/</code></td><td>MinIO; S3-compatible object storage for binary assets and agent outputs</td></tr><tr><td><code>oracle.mk</code></td><td><code>services/persistence/</code></td><td>Make targets: oracle-up/down/health/logs/build/push/publish/tag/clean/nuke</td></tr><tr><td><code>cerebro.mk</code></td><td><code>services/vector/</code></td><td>Make targets: cerebro-up/down/health/logs/build/push/publish/tag/clean/nuke</td></tr><tr><td><code>tardis.mk</code></td><td><code>services/storage/</code></td><td>Make targets: tardis-up/down/health/logs/build/push/publish/tag/clean/nuke</td></tr></tbody></table><h2 id="port-reference" tabindex="-1">Port Reference <a class="header-anchor" href="#port-reference" aria-label="Permalink to &quot;Port Reference&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Service</th><th>Container Port</th><th>Host Binding</th><th>Purpose</th></tr></thead><tbody><tr><td>Oracle</td><td>5432</td><td><code>127.0.0.1:5432</code></td><td>Postgres wire protocol</td></tr><tr><td>Cerebro</td><td>6333</td><td><code>127.0.0.1:6333</code></td><td>Qdrant REST API + Prometheus metrics</td></tr><tr><td>Cerebro</td><td>6334</td><td><code>127.0.0.1:6334</code></td><td>Qdrant gRPC API</td></tr><tr><td>Tardis</td><td>9000</td><td><code>127.0.0.1:9000</code></td><td>MinIO S3 API</td></tr><tr><td>Tardis</td><td>9001</td><td><code>127.0.0.1:9001</code></td><td>MinIO web console</td></tr></tbody></table><h2 id="network-strategy" tabindex="-1">Network Strategy <a class="header-anchor" href="#network-strategy" aria-label="Permalink to &quot;Network Strategy&quot;">​</a></h2><p>All three services join <code>arc_platform_net</code> only — the shared bridge already used by Flash, Strange, Sonic, and Cortex. No new networks are created by this feature.</p>`,35)),(a(),d(i,null,{default:t(()=>[c(r,{id:"mermaid-593",class:"mermaid",graph:"graph%20LR%0A%20%20%20%20subgraph%20arc_platform_net%20%5Barc_platform_net%20%E2%80%94%20external%2C%20shared%5D%0A%20%20%20%20%20%20%20%20oracle%5Barc-sql-db%5D%0A%20%20%20%20%20%20%20%20cerebro%5Barc-vector-db%5D%0A%20%20%20%20%20%20%20%20tardis%5Barc-storage%5D%0A%20%20%20%20%20%20%20%20cortex%5Barc-cortex%5D%0A%20%20%20%20%20%20%20%20flash%5Barc-messaging%5D%0A%20%20%20%20%20%20%20%20sonic%5Barc-cache%5D%0A%20%20%20%20%20%20%20%20strange%5Barc-streaming%5D%0A%20%20%20%20end%0A"})]),fallback:t(()=>[...e[1]||(e[1]=[s(" Loading... ",-1)])]),_:1})),e[4]||(e[4]=o('<p><strong>Rules:</strong></p><ul><li><code>arc_platform_net</code> declared <code>external: true</code> in each compose file — created by <code>make dev</code> or <code>make flash-up</code></li><li>Data services join <code>arc_platform_net</code> only (no <code>arc_otel_net</code>)</li><li>Container hostnames (<code>arc-sql-db</code>, <code>arc-vector-db</code>, <code>arc-storage</code>) are DNS-resolvable by all services on the network</li></ul><h2 id="edge-cases" tabindex="-1">Edge Cases <a class="header-anchor" href="#edge-cases" aria-label="Permalink to &quot;Edge Cases&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Scenario</th><th>Expected Behavior</th></tr></thead><tbody><tr><td>Oracle first run — empty data directory</td><td>Postgres auto-initializes using <code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_DB</code> env vars; no manual init needed</td></tr><tr><td>Cortex connects to Oracle before ready</td><td>Cortex retries with exponential backoff; <code>/health/deep</code> reflects <code>oracle: unreachable</code> until Oracle health check passes</td></tr><tr><td>MinIO starts with no buckets</td><td>MinIO starts empty; buckets must be created by Cortex bootstrap or operator via console / <code>mc</code> client</td></tr><tr><td>Cerebro disk full</td><td>Qdrant returns 507 Insufficient Storage; operator must resize the named volume</td></tr><tr><td><code>make data-up</code> before <code>arc_platform_net</code> exists</td><td>Docker compose fails at network lookup; run <code>make dev</code> or <code>docker network create arc_platform_net</code> first</td></tr><tr><td>Oracle password changed post-init</td><td>Postgres ignores <code>POSTGRES_PASSWORD</code> after data dir is initialized; operator must <code>make oracle-nuke</code> to reset</td></tr><tr><td>Tardis credentials mismatch (env vs stored config)</td><td>MinIO refuses to start; <code>make tardis-nuke</code> resets the volume and stored config</td></tr></tbody></table><h2 id="success-criteria" tabindex="-1">Success Criteria <a class="header-anchor" href="#success-criteria" aria-label="Permalink to &quot;Success Criteria&quot;">​</a></h2><ul><li>[ ] SC-1: <code>make data-up &amp;&amp; make data-health</code> exits 0 with all three services healthy</li><li>[ ] SC-2: <code>curl -s http://localhost:8081/health/deep | jq .oracle.status</code> returns <code>&quot;ok&quot;</code> after <code>make cortex-docker-up</code></li><li>[ ] SC-3: <code>curl -s http://localhost:6333/readyz</code> returns HTTP 200 (Qdrant ready)</li><li>[ ] SC-4: MinIO console accessible at <code>http://localhost:9001</code> with <code>arc</code> / <code>arc-minio-dev</code> credentials</li><li>[ ] SC-5: <code>data-images.yml</code> CI completes in under 3 minutes for an amd64-only change</li><li>[ ] SC-6: <code>git tag data/v0.1.0 &amp;&amp; git push --tags</code> triggers <code>data-release.yml</code>; all three multi-platform images published to GHCR</li><li>[ ] SC-7: All Dockerfiles pass <code>trivy image</code> scan with zero CRITICAL CVEs</li><li>[ ] SC-8: <code>services/profiles.yaml</code> <code>think</code> profile includes <code>oracle</code> and <code>cerebro</code>; <code>reason</code> profile includes <code>tardis</code></li></ul><h2 id="docs-links-update" tabindex="-1">Docs &amp; Links Update <a class="header-anchor" href="#docs-links-update" aria-label="Permalink to &quot;Docs &amp; Links Update&quot;">​</a></h2><ul><li>[ ] Update <code>services/profiles.yaml</code> — add oracle + cerebro to <code>think</code>; tardis to <code>reason</code></li><li>[ ] Verify <code>services/cortex/service.yaml</code> <code>depends_on</code> includes <code>oracle</code> codename</li><li>[ ] Update <code>CLAUDE.md</code> monorepo layout section to reference <code>persistence/</code>, <code>vector/</code>, <code>storage/</code> directories</li></ul><h2 id="constitution-compliance" tabindex="-1">Constitution Compliance <a class="header-anchor" href="#constitution-compliance" aria-label="Permalink to &quot;Constitution Compliance&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Principle</th><th>Applies</th><th>Compliant</th><th>Notes</th></tr></thead><tbody><tr><td>I. Zero-Dep CLI</td><td>[ ]</td><td>n/a</td><td>Services only — no CLI changes</td></tr><tr><td>II. Platform-in-a-Box</td><td>[x]</td><td>[x]</td><td><code>make data-up</code> boots all three; oracle + cerebro join <code>think</code> profile</td></tr><tr><td>III. Modular Services</td><td>[x]</td><td>[x]</td><td>Each service self-contained in own directory; flat under <code>services/</code></td></tr><tr><td>IV. Two-Brain</td><td>[x]</td><td>[x]</td><td>Config-only upstream images — no language concern</td></tr><tr><td>V. Polyglot Standards</td><td>[x]</td><td>[x]</td><td>Dockerfiles, compose, health checks follow established 003 pattern</td></tr><tr><td>VI. Local-First</td><td>[ ]</td><td>n/a</td><td>CLI-only principle</td></tr><tr><td>VII. Observability</td><td>[x]</td><td>[x]</td><td>Qdrant exposes Prometheus on :6333; MinIO health on :9000; Oracle via pg_isready</td></tr><tr><td>VIII. Security</td><td>[x]</td><td>[x]</td><td>Non-root containers; 127.0.0.1-only port binding; credentials via env, not git</td></tr><tr><td>IX. Declarative</td><td>[ ]</td><td>n/a</td><td>CLI-only principle</td></tr><tr><td>X. Stateful Ops</td><td>[ ]</td><td>n/a</td><td>CLI-only principle</td></tr><tr><td>XI. Resilience</td><td>[x]</td><td>[x]</td><td>Health checks with start_periods; named volumes survive container restart</td></tr><tr><td>XII. Interactive</td><td>[ ]</td><td>n/a</td><td>CLI-only principle</td></tr></tbody></table>',10))])}const C=n(p,[["render",u]]);export{y as __pageData,C as default};
